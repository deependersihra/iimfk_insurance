<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DocRegistry DApp with IPFS + Lighthouse</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <h2>üìÑ Document Registry</h2>

  <input type="file" id="fileInput" />
  <input type="text" id="filename" placeholder="Enter filename" />
  <br><br>
  <button onclick="registerDoc()">Register with NFT.Storage</button>
  <button onclick="uploadLighthouse()">Upload with Lighthouse</button>

  <br><br>

  <input type="text" id="hashInput" placeholder="Enter docHash to check" />
  <button onclick="checkDoc()">Check Document</button>

  <pre id="output"></pre>

  <!-- Lighthouse SDK as module -->
  <script type="module">
    import lighthouse from "https://esm.sh/@lighthouse-web3/sdk@0.4.2";

    // ‚úÖ Replace with your deployed contract address
    const contractAddress = "0x1766209d8c33204260ea42951f079f60a193bcf8"; 
    
    // ‚úÖ Contract ABI
    const abi = [
      "function getDocument(bytes32 docHash) external view returns (address, uint256, string memory, string memory)",
      "function isRegistered(bytes32 docHash) external view returns (bool)"
    ];

    // ‚úÖ API Keys
	const NFT_STORAGE_KEY ="e09f5630.9922437dcfa04586b53a7591478116da"   // nft.storage
    const LIGHTHOUSE_KEY  = "b2e9e529.525f4cfdd5b74035a5769ee1808907b6";    // lighthouse.storage

    //const NFT_STORAGE_KEY = "YOUR_NFT_STORAGE_KEY";
    //const LIGHTHOUSE_KEY = "YOUR_LIGHTHOUSE_API_KEY";

    let provider, signer, contract;

    async function init() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(contractAddress, abi, signer);
        document.getElementById("output").innerText = "‚úÖ Connected to MetaMask";
      } else {
        alert("Please install MetaMask!");
      }
    }

    init();

    // Hash file
    async function getFileHash(file) {
      const buffer = await file.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      return ethers.utils.keccak256(bytes);
    }

    // Upload to NFT.Storage
    async function uploadToNFTStorage(file) {
      const endpoint = "https://api.nft.storage/upload";
      const response = await fetch(endpoint, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${NFT_STORAGE_KEY}`,
          "Content-Type": "application/octet-stream"
        },
        body: file
      });
      const data = await response.json();
      return data.value.cid; // ‚úÖ NFT.Storage CID
    }

    // Upload to Lighthouse
    async function uploadLighthouse() {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      if (!file) {
        alert("Please select a file first");
        return;
      }

      try {
        const result = await lighthouse.upload(file, LIGHTHOUSE_KEY);
        console.log(result);

        document.getElementById("output").textContent =
          `‚úÖ Lighthouse Upload Complete\nCID: ${result.data.Hash}\nURL: https://gateway.lighthouse.storage/ipfs/${result.data.Hash}`;
      } catch (err) {
        document.getElementById("output").textContent = "‚ùå Lighthouse Error: " + err.message;
      }
    }

    // Register doc with NFT.Storage
    async function registerDoc() {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      const filename = document.getElementById("filename").value || (file ? file.name : "");

      if (!file) {
        alert("Please select a file");
        return;
      }

      try {
        const docHash = await getFileHash(file);
        const ipfsCid = await uploadToNFTStorage(file);

        document.getElementById("output").innerText = `‚úÖ Document registered:
        Hash: ${docHash}
        CID: ${ipfsCid}
        Filename: ${filename}`;
      } catch (err) {
        document.getElementById("output").innerText = "‚ùå Error: " + err.message;
      }
    }

    // Check doc
    async function checkDoc() {
      const docHash = document.getElementById("hashInput").value;
      try {
        const registered = await contract.isRegistered(docHash);
        if (!registered) {
          document.getElementById("output").innerText = "‚ùå Document not found";
          return;
        }
        const doc = await contract.getDocument(docHash);
        document.getElementById("output").innerText =
          `‚úÖ Registered
           Uploader: ${doc[0]}
           Timestamp: ${new Date(doc[1] * 1000)}
           IPFS: https://ipfs.io/ipfs/${doc[2]}
           Filename: ${doc[3]}`;
      } catch (err) {
        document.getElementById("output").innerText = "‚ùå Error: " + err.message;
      }
    }

    // ‚úÖ Make functions available globally
    window.registerDoc = registerDoc;
    window.uploadLighthouse = uploadLighthouse;
    window.checkDoc = checkDoc;
  </script>
</body>
</html>
